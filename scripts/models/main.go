package main

import (
	"bytes"
	"context"
	_ "embed"
	"encoding/json"
	"fmt"
	"go/format"
	"io"
	"log"
	"net/http"
	"os"
	"strings"
	"text/template"

	"github.com/ettle/strcase"
)

//go:embed models.go.txt
var outputFileTemplate string

type templateParams struct {
	Models []ResponseModel `json:"models"`
}

const (
	outputFile       = "models.go"
	outputFileHeader = `
// Code generated by github.com/conneroisu/groq-go/scripts/models/main.go DO NOT EDIT.

package groq

`
	modelsInitURL = "https://console.groq.com/docs/models"
)

// each model~:
//
// Distil-Whisper English
//
//     Model ID: distil-whisper-large-v3-en
//     Developer: HuggingFace
//     Max File Size: 25 MB
//     [ Model Card ](https://huggingface.co/distil-whisper-large-v3-en)
//
// Need to then go to the huggingface page and take the first tag Text-Generation (Llama) or Automatic-Speech-Recognition (Whisper).

// main is the entry point for the application.
func main() {
	ctx := context.Background()
	if err := run(ctx); err != nil {
		log.Fatal(err)
	}
}

// Response is a response from the models endpoint.
type Response struct {
	Object string          `json:"object"`
	Data   []ResponseModel `json:"data"`
}

// ResponseModel is a response from the models endpoint.
type ResponseModel struct {
	ID            string `json:"id"`
	Name          string `json:"name,omitempty"`
	Object        string `json:"object"`
	Created       int    `json:"created"`
	OwnedBy       string `json:"owned_by"`
	Active        bool   `json:"active"`
	ContextWindow int    `json:"context_window"`
	PublicApps    any    `json:"public_apps"`
}

// run runs the main function.
func run(ctx context.Context) error {
	client := &http.Client{}
	req, err := http.NewRequest(
		"GET",
		"https://api.groq.com/openai/v1/models",
		nil,
	)
	if err != nil {
		return err
	}
	key := os.Getenv("GROQ_KEY")
	if key == "" {
		return fmt.Errorf("GROQ_KEY is not set")
	}
	req.Header.Set("Authorization", "Bearer "+key)
	req.Header.Set("Content-Type", "application/json")
	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	bodyText, err := io.ReadAll(resp.Body)
	if err != nil {
		return err
	}
	var response Response
	err = json.Unmarshal(bodyText, &response)
	if err != nil {
		return err
	}
	buf := new(bytes.Buffer)
	models := response.Data
	nameModels(models)
	err = fillTemplate(buf, models)
	if err != nil {
		return err
	}
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("error formatting output: %w : %s", err, buf.String())
	}
	f, err := os.Create(outputFile)
	if err != nil {
		return err
	}
	defer f.Close()
	_, err = f.Write(formatted)
	if err != nil {
		return err
	}
	return nil
}

func fillTemplate(w io.Writer, models []ResponseModel) error {
	funcMap := template.FuncMap{
		"isTextModel": func(model ResponseModel) bool {
			// if context window is greater than 1024 then it is a text model
			return model.ContextWindow > 1024
		},
		"isAudioModel": func(model ResponseModel) bool {
			// if context window is less than 1024 then it is a audio model
			return model.ContextWindow < 1024
		},
	}
	tmpla, err := template.New("output").
		Funcs(funcMap).
		Parse(outputFileTemplate)
	if err != nil {
		return err
	}
	err = tmpla.Execute(w, templateParams{Models: models})
	if err != nil {
		return err
	}
	return nil
}

// nameModels
func nameModels(models []ResponseModel) {
	for i, _ := range models {
		if (models)[i].Name == "" {
			filtered := strings.Replace(models[i].ID, "-", "_", -1)
			filtered = strings.Replace(filtered, ".", "_", -1)
			models[i].Name = strcase.ToGoCase(filtered, strcase.TitleCase, bytes.Runes([]byte("_"))[0])
		}
	}
}
